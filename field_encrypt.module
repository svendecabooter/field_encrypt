<?php
/**
 * @file
 * Contains module hooks for field_encrypt.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;

/**
 * Implements hook_form_alter().
 *
 * Adds settings to the field storage configuration forms to allow setting the
 * encryption state.
 */
function field_encrypt_form_alter(&$form, FormStateInterface $form_state, $form_id) {

  // If this is the add or edit form for field_storage, we call our function.
  if (in_array($form_id, ['field_storage_add_form', 'field_storage_config_edit_form'])) {

    // Check permissions.
    $user = \Drupal::currentUser();
    if ($user->hasPermission('administer field encryption')) {
      /* @var $field \Drupal\field\Entity\FieldStorageConfig */
      $field = $form_state->getFormObject()->getEntity();
      $field_type = $field->getType();
      $default_properties = \Drupal::config('field_encrypt.settings')->get('default_properties');

      // Add container for field_encrypt specific settings.
      $form['field_encrypt'] = array(
        '#type' => 'details',
        '#title' => t('Field encryption'),
        '#open' => TRUE,
      );

      // Display a warning about changing field data.
      if ($form_id == "field_storage_config_edit_form" && $field->hasData()) {
        $form['field_encrypt']['#prefix'] = '<div class="messages messages--warning">' . t('Warning: changing field encryption settings may cause data corruption!<br />When changing these settings, existing fields will be (re)encrypted in batch according to the new settings. <br />Make sure you have a proper backup, and do not perform this action in an environment where the data will be changing during the batch operation, to avoid data loss.') . '</div>';
      }

      $form['field_encrypt']['field_encrypt'] = array(
        '#type' => 'container',
        '#tree' => TRUE,
      );

      // Add setting to decide if field should be encrypted.
      $form['field_encrypt']['field_encrypt']['encrypt'] = [
        '#type' => 'checkbox',
        '#title' => t('Encrypt field'),
        '#description' => t('Makes the field storage encrypted.'),
        '#default_value' => $field->getThirdPartySetting('field_encrypt', 'encrypt', FALSE),
      ];

      $properties = [];
      $definitions = $field->getPropertyDefinitions();
      foreach ($definitions as $property => $definition) {
        $properties[$property] = $definition->getLabel();
      }

      $form['field_encrypt']['field_encrypt']['properties'] = [
        '#type' => 'checkboxes',
        '#title' => t('Properties'),
        '#description' => t('Specify the field properties to encrypt.'),
        '#options' => $properties,
        '#default_value' => $field->getThirdPartySetting('field_encrypt', 'properties', $default_properties[$field_type]),
        '#states' => [
          'visible' => [
            ':input[name="field_encrypt[encrypt]"]' => array('checked' => TRUE),
          ],
        ],
      ];

      $encryption_profile_manager = \Drupal::service('encrypt.encryption_profile.manager');
      $form['field_encrypt']['field_encrypt']['encryption_profile'] = array(
        '#type' => 'select',
        '#title' => t('Encryption profile'),
        '#description' => t('Select the encryption profile to use for encrypting this field.'),
        '#options' => $encryption_profile_manager->getEncryptionProfileNamesAsOptions(),
        '#default_value' => $field->getThirdPartySetting('field_encrypt', 'encryption_profile', FALSE),
        '#states' => [
          'visible' => [
            ':input[name="field_encrypt[encrypt]"]' => array('checked' => TRUE),
          ],
        ],
      );

      // We add functions to process the form when it is saved.
      $form['actions']['submit']['#submit'][] = 'field_encrypt_update_encryption_form_submit';
      $form['#entity_builders'][] = 'field_encrypt_form_field_add_form_builder';
    }
  }
}

/**
 * Update the field storage configuration to set the encryption state.
 *
 * @param string $entity_type
 *   The entity type.
 * @param \Drupal\field\Entity\FieldStorageConfig $field_storage_config
 *   The field storage config entity.
 * @param array $form
 *   The complete form array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The current state of the form.
 */
function field_encrypt_form_field_add_form_builder($entity_type, \Drupal\field\Entity\FieldStorageConfig $field_storage_config, &$form, \Drupal\Core\Form\FormStateInterface $form_state) {
  $field_encryption_settings = $form_state->getValue('field_encrypt');
  $field_encryption_settings['encrypt'] = (bool) $field_encryption_settings['encrypt'];
  $original_encryption = $field_storage_config->getThirdPartySettings('field_encrypt');

  // If the form has the value, we set it.
  if ($field_encryption_settings['encrypt']) {
    foreach ($field_encryption_settings as $settings_key => $settings_value) {
      $field_storage_config->setThirdPartySetting('field_encrypt', $settings_key, $settings_value);
    }
  }
  else {
    // If there is no value, remove third party settings.
    $field_storage_config->unsetThirdPartySetting('field_encrypt', 'encrypt');
    $field_storage_config->unsetThirdPartySetting('field_encrypt', 'properties');
    $field_storage_config->unsetThirdPartySetting('field_encrypt', 'encryption_profile');
  }

  // Check if existing data will need to be updated when changing settings.
  if ($original_encryption !== $field_storage_config->getThirdPartySettings('field_encrypt')) {
    // Only re-encrypt field data if this field contains actual data.
    if ($field_storage_config->hasData()) {
      // We need to process the field to either encrypt or decrypt the stored
      // fields if the setting was changed.
      // See field_encrypt_update_encryption_form_submit()
      $storage = $form_state->getStorage();
      $storage['field_encrypt_update'] = TRUE;
      $storage['field_encrypt_field_name'] = $field_storage_config->get('field_name');
      $storage['field_encrypt_entity_type'] = $field_storage_config->get('entity_type');
      $storage['original_encryption_settings'] = $original_encryption;
      $form_state->setStorage($storage);
    }
  }
}

/**
 * Submit handler to update encryption after saving field storage settings.
 *
 * @param array $form
 *   An associative array containing the structure of the form.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The current state of the form.
 */
function field_encrypt_update_encryption_form_submit(&$form, FormStateInterface $form_state) {
  $storage = $form_state->getStorage();
  $entity_type_manager = \Drupal::service('entity_type.manager');
  // If the flag is set to update existing fields, run a batch process to do so.
  if (isset($storage['field_encrypt_update']) && $storage['field_encrypt_update'] == TRUE) {
    $entity_type_id = $storage['field_encrypt_entity_type'];
    $entity_type = $entity_type_manager->getDefinition($entity_type_id);
    $field_name = $storage['field_encrypt_field_name'];
    $original_encryption_settings = $storage['original_encryption_settings'];

    // Get entities that need updating, because they contain the field that has
    // its field encryption settings updated.
    $entity_query = \Drupal::service('entity.query');
    $query = $entity_query->get($entity_type_id);
    // Check if the field is present.
    $query->exists($field_name);
    // Make sure to get all revisions for revisionable entities.
    if ($entity_type->hasKey('revision')) {
      $query->allRevisions();
    }
    $entity_ids = $query->execute();

    // Configure the batch operation to be called, with the appropriate
    // parameters to process the loaded entity IDs that need updating.
    $batch = array(
      'title' => t('Updating field encryption'),
      'operations' => array(
        array('field_encrypt_update_field_encryption', array(
          array_keys($entity_ids),
          $field_name,
          $entity_type_id,
          $original_encryption_settings,
        ),
        ),
      ),
      'finished' => 'field_encrypt_update_field_encryption_finished',
    );
    batch_set($batch);
  }
}

/**
 * Callback for batch updating of encryption fields.
 *
 * @param array $entity_ids
 *   The entity IDs to update with the new field encryption settings.
 * @param string $field_name
 *   The name of the field that his its encryption settings changed.
 * @param string $field_entity_type
 *   The entity type whose field storage settings have been changed.
 * @param array $original_encryption_settings
 *   The original field encryption settings, before they where changed.
 * @param array $context
 *   The batch API context.
 */
function field_encrypt_update_field_encryption($entity_ids, $field_name, $field_entity_type, $original_encryption_settings, &$context) {
  $process_entities = \Drupal::service('field_encrypt.process_entities');
  if (empty($context['sandbox'])) {
    $context['sandbox']['entity_ids'] = $entity_ids;
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['max'] = count($entity_ids);
  }

  $config = \Drupal::config('field_encrypt_admin_settings');
  // Process entities in groups. Default batch size is 5.
  $count = min($config->get('batch_size'), count($context['sandbox']['entity_ids']));
  for ($i = 1; $i <= $count; $i++) {
    $entity_id = array_shift($context['sandbox']['entity_ids']);
    /* @var $entity_storage Drupal\Core\Entity\EntityStorageInterface */
    $process_entities->updateStoredField($field_name, $field_entity_type, $original_encryption_settings, $entity_id);
    $context['results'][] = $entity_id;
    // Update our progress information.
    $context['sandbox']['progress']++;
  }

  // Inform the batch engine that we are not finished,
  // and provide an estimation of the completion level we reached.
  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

/**
 * Callback for finishing batch encryption updates of fields.
 *
 * @param bool $success
 *   A boolean indicating whether the batch has completed successfully.
 * @param array $results
 *   The value set in $context['results'] by callback_batch_operation().
 * @param array $operations
 *   If $success is FALSE, contains the operations that remained unprocessed.
 */
function field_encrypt_update_field_encryption_finished($success, $results, $operations) {
  // The 'success' parameter means no fatal PHP errors were detected. All
  // other error management should be handled using 'results'.
  if ($success) {
    $message = \Drupal::translation()->formatPlural(count($results), 'One field updated.', '@count fields updated.');
  }
  else {
    $message = t('Finished with an error.');
  }
  drupal_set_message($message);
}

/**
 * Implements hook_entity_insert().
 *
 * Encrypts the entity after being saved for the first time.
 */
function field_encrypt_entity_insert(EntityInterface $entity) {
  if (field_encrypt_allow_encryption($entity)) {
    \Drupal::service('field_encrypt.encrypted_field_value_manager')->saveEncryptedFieldValues($entity);
  }
}

/**
 * Implements hook_entity_update().
 *
 * Encrypts the entity after being updated.
 */
function field_encrypt_entity_update(EntityInterface $entity) {
  if (field_encrypt_allow_encryption($entity)) {
    \Drupal::service('field_encrypt.encrypted_field_value_manager')->saveEncryptedFieldValues($entity);
  }
}

/**
 * Implements hook_entity_presave().
 *
 * Encrypt entity fields before they are saved.
 */
function field_encrypt_entity_presave(EntityInterface $entity) {
  if (field_encrypt_allow_encryption($entity)) {
    \Drupal::service('field_encrypt.process_entities')->encryptEntity($entity);
  }
}

/**
 * Implements hook_entity_storage_load().
 *
 * Decrypt entity fields when loading entities.
 */
function field_encrypt_entity_storage_load($entities, $entity_type) {
  /* @var $field_encrypt_process_entities \Drupal\field_encrypt\FieldEncryptProcessEntities */
  $field_encrypt_process_entities = \Drupal::service('field_encrypt.process_entities');

  foreach ($entities as &$entity) {
    if (field_encrypt_allow_encryption($entity)) {
      if ($field_encrypt_process_entities->entityHasEncryptedFields($entity)) {
        $field_encrypt_process_entities->decryptEntity($entity);
      }
    }
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Remove EncryptedFieldValues associated with this entity.
 */
function field_encrypt_entity_delete(EntityInterface $entity) {
  if (field_encrypt_allow_encryption($entity)) {
    $encrypted_field_value_manager = \Drupal::service('field_encrypt.encrypted_field_value_manager');
    $encrypted_field_value_manager->deleteEncryptedFieldValues($entity);
  }
}

/**
 * Verify if the given entity allows to be encrypted.
 *
 * @param \Drupal\Core\Entity\EntityInterface $entity
 *   The entity to check.
 *
 * @return bool
 *   Boolean indicating hether the entity could be encrypted.
 */
function field_encrypt_allow_encryption(EntityInterface $entity) {
  $allowed = TRUE;

  // We don't want to encrypt the encrypted data storage.
  if ($entity instanceof Drupal\field_encrypt\Entity\EncryptedFieldValueInterface) {
    $allowed = FALSE;
  }

  // We only want to encrypt content entities.
  if (!$entity instanceof Drupal\Core\Entity\ContentEntityInterface) {
    $allowed = FALSE;
  }
  return $allowed;
}
